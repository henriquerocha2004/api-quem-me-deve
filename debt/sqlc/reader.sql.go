// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: reader.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const clientUserDebts = `-- name: ClientUserDebts :many
SELECT 
    id, 
    description,
    total_value,
    due_date,
    installments_quantity,
    debt_date,
    status,
    user_client_id,
    product_ids,
    service_ids,
    finished_at
FROM public.debts
WHERE user_client_id = $1
ORDER BY created_at DESC
`

type ClientUserDebtsRow struct {
	ID                   string       `json:"id"`
	Description          string       `json:"description"`
	TotalValue           string       `json:"total_value"`
	DueDate              sql.NullTime `json:"due_date"`
	InstallmentsQuantity int32        `json:"installments_quantity"`
	DebtDate             sql.NullTime `json:"debt_date"`
	Status               string       `json:"status"`
	UserClientID         string       `json:"user_client_id"`
	ProductIds           []string     `json:"product_ids"`
	ServiceIds           []string     `json:"service_ids"`
	FinishedAt           sql.NullTime `json:"finished_at"`
}

// description: Get all debts for a specific user client
func (q *Queries) ClientUserDebts(ctx context.Context, userClientID string) ([]ClientUserDebtsRow, error) {
	rows, err := q.db.QueryContext(ctx, clientUserDebts, userClientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientUserDebtsRow
	for rows.Next() {
		var i ClientUserDebtsRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.TotalValue,
			&i.DueDate,
			&i.InstallmentsQuantity,
			&i.DebtDate,
			&i.Status,
			&i.UserClientID,
			pq.Array(&i.ProductIds),
			pq.Array(&i.ServiceIds),
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const debtByFilters = `-- name: DebtByFilters :many
SELECT 
    id, 
    description,
    total_value,
    due_date,
    installments_quantity,
    debt_date,
    status,
    user_client_id,
    product_ids,
    service_ids,
    finished_at
FROM public.debts
WHERE 
    ($1::TEXT IS NULL OR user_client_id = $1) AND
    ($2::TEXT IS NULL OR status = $2) AND
    ($3::TIMESTAMP IS NULL OR due_date >= $3) AND
    ($4::TIMESTAMP IS NULL OR due_date <= $4)
ORDER BY created_at DESC LIMIT $5 OFFSET $6
`

type DebtByFiltersParams struct {
	Column1 string    `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type DebtByFiltersRow struct {
	ID                   string       `json:"id"`
	Description          string       `json:"description"`
	TotalValue           string       `json:"total_value"`
	DueDate              sql.NullTime `json:"due_date"`
	InstallmentsQuantity int32        `json:"installments_quantity"`
	DebtDate             sql.NullTime `json:"debt_date"`
	Status               string       `json:"status"`
	UserClientID         string       `json:"user_client_id"`
	ProductIds           []string     `json:"product_ids"`
	ServiceIds           []string     `json:"service_ids"`
	FinishedAt           sql.NullTime `json:"finished_at"`
}

// description: Get debts by various filters
func (q *Queries) DebtByFilters(ctx context.Context, arg DebtByFiltersParams) ([]DebtByFiltersRow, error) {
	rows, err := q.db.QueryContext(ctx, debtByFilters,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DebtByFiltersRow
	for rows.Next() {
		var i DebtByFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.TotalValue,
			&i.DueDate,
			&i.InstallmentsQuantity,
			&i.DebtDate,
			&i.Status,
			&i.UserClientID,
			pq.Array(&i.ProductIds),
			pq.Array(&i.ServiceIds),
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const debtCancelInfo = `-- name: DebtCancelInfo :one
SELECT 
    id,
    reason,
    cancel_date,
    cancelled_by,
    debt_id
FROM public.cancel_info
WHERE debt_id = $1
`

type DebtCancelInfoRow struct {
	ID          string       `json:"id"`
	Reason      string       `json:"reason"`
	CancelDate  sql.NullTime `json:"cancel_date"`
	CancelledBy string       `json:"cancelled_by"`
	DebtID      string       `json:"debt_id"`
}

// description: Get cancel info for a specific debt
func (q *Queries) DebtCancelInfo(ctx context.Context, debtID string) (DebtCancelInfoRow, error) {
	row := q.db.QueryRowContext(ctx, debtCancelInfo, debtID)
	var i DebtCancelInfoRow
	err := row.Scan(
		&i.ID,
		&i.Reason,
		&i.CancelDate,
		&i.CancelledBy,
		&i.DebtID,
	)
	return i, err
}

const debtInstallments = `-- name: DebtInstallments :many
SELECT 
    id,
    description,
    value,
    due_date,
    deb_date,
    status,
    payment_date,
    payment_method,
    number,
    debt_id
FROM public.installments
WHERE debt_id = $1
ORDER BY number
`

type DebtInstallmentsRow struct {
	ID            string         `json:"id"`
	Description   string         `json:"description"`
	Value         string         `json:"value"`
	DueDate       sql.NullTime   `json:"due_date"`
	DebDate       sql.NullTime   `json:"deb_date"`
	Status        string         `json:"status"`
	PaymentDate   sql.NullTime   `json:"payment_date"`
	PaymentMethod sql.NullString `json:"payment_method"`
	Number        int32          `json:"number"`
	DebtID        string         `json:"debt_id"`
}

// description: Get all installments for a specific debt
func (q *Queries) DebtInstallments(ctx context.Context, debtID string) ([]DebtInstallmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, debtInstallments, debtID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DebtInstallmentsRow
	for rows.Next() {
		var i DebtInstallmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Value,
			&i.DueDate,
			&i.DebDate,
			&i.Status,
			&i.PaymentDate,
			&i.PaymentMethod,
			&i.Number,
			&i.DebtID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const debtReversalInfo = `-- name: DebtReversalInfo :one
SELECT 
    id,
    reason,
    reversal_date,
    reversed_by,
    reversed_installment_qtd,
    cancelled_installment_qtd,
    debt_id
FROM public.reversal_info
WHERE debt_id = $1
`

type DebtReversalInfoRow struct {
	ID                      string       `json:"id"`
	Reason                  string       `json:"reason"`
	ReversalDate            sql.NullTime `json:"reversal_date"`
	ReversedBy              string       `json:"reversed_by"`
	ReversedInstallmentQtd  int32        `json:"reversed_installment_qtd"`
	CancelledInstallmentQtd int32        `json:"cancelled_installment_qtd"`
	DebtID                  string       `json:"debt_id"`
}

// description: Get reversal info for a specific debt
func (q *Queries) DebtReversalInfo(ctx context.Context, debtID string) (DebtReversalInfoRow, error) {
	row := q.db.QueryRowContext(ctx, debtReversalInfo, debtID)
	var i DebtReversalInfoRow
	err := row.Scan(
		&i.ID,
		&i.Reason,
		&i.ReversalDate,
		&i.ReversedBy,
		&i.ReversedInstallmentQtd,
		&i.CancelledInstallmentQtd,
		&i.DebtID,
	)
	return i, err
}
